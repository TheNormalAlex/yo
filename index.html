<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>INSANE Three.js Visualizer</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <style>
        body { margin:0; padding:0; overflow: hidden; background-color: #000; }
        canvas { display: block; } /* Ensures canvas fills container and no extra space */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

<div id="info">Hover or Click on a shape!</div>

<!-- Three.js Library -->
<!-- Using cdnjs for ease of single-file example -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.154.0/three.min.js"></script>
<!-- OrbitControls for easy camera movement - USING THE CLASSIC /js/ VERSION -->
<!-- This script will likely add OrbitControls to the global THREE object -->
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
<!-- TWEEN.js for animations (optional, but used for click effect) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js"></script>


<script>
    let scene, camera, renderer, controls;
    let objects = []; // Array to hold all our 3D objects
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let intersectedObject = null; // To track the object currently being hovered

    const objectCount = 300; // Number of objects
    // const interactionDistance = 10; // Raycaster distance limit - not strictly needed if using intersectedObjects directly

    init();
    animate();

    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111); // Dark background

        // Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100; // Start the camera a bit back

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement); // Add canvas to body

        // Controls setup (for orbiting/panning/zooming)
        // Accessing OrbitControls via the THREE object as it's defined by the /js/ script
        controls = new THREE.OrbitControls(camera, renderer.domElement); // <--- CHANGED HERE
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false; // Keep vertical panning locked to up/down world axis
        controls.maxDistance = 500;
        controls.minDistance = 10;


        // Lights
        const ambientLight = new THREE.AmbientLight(0xaaaaaa); // Soft white light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Directional light
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xff00ff, 1, 100); // Pink point light
        pointLight.position.set(50, 50, -50);
        scene.add(pointLight);

         const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100); // Cyan point light
        pointLight2.position.set(-50, -50, 50);
        scene.add(pointLight2);


        // Create various geometries
        const geometries = [
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.SphereGeometry(0.75, 16, 16), // Smaller sphere
            new THREE.ConeGeometry(0.75, 1.5, 16),
            new THREE.CylinderGeometry(0.75, 0.75, 1.5, 16),
            new THREE.TorusGeometry(0.5, 0.2, 10, 20),
            new THREE.OctahedronGeometry(1),
            new THREE.DodecahedronGeometry(1)
        ];

        // Create the objects
        for (let i = 0; i < objectCount; i++) {
            // Random geometry
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];

            // Random vibrant color
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6).getHex(), // Use HSL for more vibrant random colors
                specular: 0x555555, // How shiny the surface is
                shininess: 30,     // How sharp the specular highlight is
            });

            const mesh = new THREE.Mesh(geometry, material);

            // Random position within a sphere volume
            const radius = 80;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            mesh.position.x = radius * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = radius * Math.sin(phi) * Math.sin(theta);
            mesh.position.z = radius * Math.cos(phi);

            // Random initial rotation
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;

            // Store unique animation properties for each object
            mesh.userData.speed = Math.random() * 0.01 + 0.005; // Slower/faster rotation
            mesh.userData.rotationAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(); // Random rotation axis centered around origin
            mesh.userData.originalColor = mesh.material.color.clone(); // Store original color
            mesh.userData.originalScale = mesh.scale.clone(); // Store original scale

            scene.add(mesh);
            objects.push(mesh); // Add to interactive objects list
        }

         // Set raycaster distance limit - useful for not highlighting objects too far away
         raycaster.far = camera.far;

        // Event listeners
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('click', onClick, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function onClick(event) {
        // Update the raycaster with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Check for intersections
        // true for recursive check, needed if objects had children, but not here
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
            // Get the first intersected object (closest one)
            const clickedObject = intersects[0].object;

            // Apply a click effect (e.g., scale pulse, color flash)
            // Store click time to help manage hover effects briefly after a click
            clickedObject.userData.lastClickTime = performance.now();

            // Use TWEEN.js for smoother animation if available
             if (typeof TWEEN !== 'undefined' && TWEEN.Tween) {
                 // Animate scale up and back down
                new TWEEN.Tween(clickedObject.scale)
                    .to({ x: 1.5, y: 1.5, z: 1.5 }, 150) // Scale up in 150ms
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onComplete(() => {
                         new TWEEN.Tween(clickedObject.scale)
                             .to(clickedObject.userData.originalScale, 300) // Scale back to original
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                    })
                    .start();

                // Animate color flash
                 new TWEEN.Tween(clickedObject.material.color)
                    .to(new THREE.Color(0xffffff), 100) // Flash white
                     .easing(TWEEN.Easing.Quadratic.Out)
                     .onComplete(() => {
                         // Wait briefly before restoring original color to let scale animation finish
                         setTimeout(() => {
                             // Ensure object wasn't just hovered and changed color again
                            if ((performance.now() - clickedObject.userData.lastClickTime) < 500) { // Check if recent click
                                new TWEEN.Tween(clickedObject.material.color)
                                    .to(clickedObject.userData.originalColor, 400) // Fade back to original
                                    .easing(TWEEN.Easing.Quadratic.Out)
                                    .start();
                             }
                         }, 50); // Wait 50ms
                     })
                     .start();

            } else {
                // Fallback if TWEEN.js isn't loaded (less smooth)
                 clickedObject.scale.set(1.5, 1.5, 1.5);
                 setTimeout(() => clickedObject.scale.copy(clickedObject.userData.originalScale), 450); // Revert after delay

                 clickedObject.material.color.setHex(0xffffff);
                  setTimeout(() => clickedObject.material.color.copy(clickedObject.userData.originalColor), 500); // Revert after delay
            }


        } else {
            // No object clicked
        }
    }


    function animate() {
        requestAnimationFrame(animate);

        // Update object positions/rotations for constant motion
        const time = performance.now() * 0.0001; // Use a slower time factor

        objects.forEach((obj, index) => {
            // Basic constant rotation around object's stored axis
            const rotationAmount = obj.userData.speed;
            obj.rotateOnAxis(obj.userData.rotationAxis, rotationAmount);

            // Add some subtle translation/wobble based on time
             obj.position.x += Math.sin(time * (index + 1) * 0.1) * 0.01;
             obj.position.y += Math.cos(time * (index + 1) * 0.15) * 0.01;
             obj.position.z += Math.sin(time * (index + 1) * 0.08) * 0.01;

            // Keep objects within bounds or wrap around (example: sphere boundary)
             const distFromCenter = obj.position.length();
             const boundaryRadius = 100;
             if (distFromCenter > boundaryRadius) {
                // Warp to opposite side and add some randomness
                 obj.position.multiplyScalar(-1);
                 obj.position.add(new THREE.Vector3(
                     THREE.MathUtils.randFloatSpread(5), // Smaller spread on warp
                     THREE.MathUtils.randFloatSpread(5),
                     THREE.MathUtils.randFloatSpread(5)
                 ));
             }
        });


        // Raycasting for hover effect
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
            // There's at least one intersection
            const firstIntersected = intersects[0].object;

            if (intersectedObject != firstIntersected) {
                // A new object is being hovered

                // Restore previous hovered object's scale and color (if any)
                if (intersectedObject) {
                    // Check if the object was just clicked before restoring color/scale
                    if (!intersectedObject.userData.lastClickTime || (performance.now() - intersectedObject.userData.lastClickTime) > 400) {
                       intersectedObject.scale.copy(intersectedObject.userData.originalScale);
                       intersectedObject.material.color.copy(intersectedObject.userData.originalColor);
                    }
                    // If it was just clicked, let the click animation finish before allowing hover state change
                }

                 // Set the new hovered object IF it wasn't just clicked
                 if (!firstIntersected.userData.lastClickTime || (performance.now() - firstIntersected.userData.lastClickTime) > 400) {
                    intersectedObject = firstIntersected;

                     // Apply hover effect (e.g., glow color, slight scale)
                    intersectedObject.material.color.setHex(0xffff00); // Highlight color (yellow)
                    // Animate scale slightly up on hover using TWEEN if available
                    if (typeof TWEEN !== 'undefined' && TWEEN.Tween) {
                         new TWEEN.Tween(intersectedObject.scale)
                             .to(intersectedObject.userData.originalScale.clone().multiplyScalar(1.1), 100)
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                     } else {
                         // Fallback if TWEEN not available
                          intersectedObject.scale.copy(intersectedObject.userData.originalScale.clone().multiplyScalar(1.1));
                     }
                 }


        }
        // If intersects.length > 0 and intersectedObject is the same, do nothing (already highlighted)

        } else {
            // No intersections
            if (intersectedObject) {
                // We were just hovering over an object, but now we're not
                // Restore its original scale and color if it wasn't just clicked
                if (!intersectedObject.userData.lastClickTime || (performance.now() - intersectedObject.userData.lastClickTime) > 400) {
                    if (typeof TWEEN !== 'undefined' && TWEEN.Tween) {
                         new TWEEN.Tween(intersectedObject.scale)
                             .to(intersectedObject.userData.originalScale, 100)
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                         new TWEEN.Tween(intersectedObject.material.color)
                            .to(intersectedObject.userData.originalColor, 100)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                     } else {
                          intersectedObject.scale.copy(intersectedObject.userData.originalScale);
                          intersectedObject.material.color.copy(intersectedObject.userData.originalColor);
                     }

                    intersectedObject = null; // Clear hovered object
                }
                 // If it *was* just clicked, we leave intersectedObject as is briefly
                 // to allow the click animation to potentially override the hover state change back.
                 // The check inside the if(intersects.length > 0) handles re-highlighting it if the mouse is still over it.
            }
        }


        // Update TWEEN.js animations if loaded
        if (typeof TWEEN !== 'undefined' && TWEEN.update) {
            TWEEN.update();
        }


        // Update controls (needed if controls.enableDamping is true)
        controls.update();

        // Render the scene
        renderer.render(scene, camera);
    }

</script>

</body>
</html>
