<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>INSANE Three.js Visualizer</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <style>
        body { margin:0; padding:0; overflow: hidden; background-color: #000; }
        canvas { display: block; } /* Ensures canvas fills container and no extra space */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
            z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

<div id="info">Hover or Click on a shape!</div>

<!-- No individual script tags for Three/OrbitControls/TWEEN here -->
<!-- We load them using import statements within the script tag below -->

<script type="module"> // <--- IMPORTANT: Set script type to "module"

    // Import Three.js library using the full URL to the module version on cdnjs
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.154.0/three.module.js';

    // Import OrbitControls using the full URL to the JSM version on cdnjs
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/controls/OrbitControls.js';

    // Import TWEEN.js using the full URL to the ES module version on cdnjs
    import { TWEEN } from 'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.js';

    // --- Rest of your script remains largely the same ---
    // You still use the THREE prefix for core Three.js components (Vector3, Mesh, Scene, etc.)
    // but use OrbitControls and TWEEN directly as imported.

    let scene, camera, renderer, controls;
    let objects = []; // Array to hold all our 3D objects
    let raycaster = new THREE.Raycaster(); // THREE prefix still needed for raycaster
    let mouse = new THREE.Vector2();     // THREE prefix still needed for Vector2
    let intersectedObject = null; // To track the object currently being hovered

    const objectCount = 300; // Number of objects

    // Initialize the scene
    init();
    // Start the animation loop
    animate();

    function init() {
        // Scene setup
        scene = new THREE.Scene(); // THREE prefix needed
        scene.background = new THREE.Color(0x111111); // THREE prefix needed

        // Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // THREE prefix needed
        camera.position.z = 100; // Start the camera a bit back

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true }); // THREE prefix needed
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement); // Add canvas to body

        // Controls setup (for orbiting/panning/zooming)
        // Now OrbitControls is imported directly, use it WITHOUT THREE. prefix
        controls = new OrbitControls(camera, renderer.domElement); // <--- CORRECT USAGE FOR ES MODULES
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false; // Keep vertical panning locked to up/down world axis
        controls.maxDistance = 500;
        controls.minDistance = 10;


        // Lights
        const ambientLight = new THREE.AmbientLight(0xaaaaaa); // THREE prefix needed
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // THREE prefix needed
        directionalLight.position.set(1, 1, 1); // Use THREE.Vector3 before normalize if you created it explicitly, set method just takes numbers
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xff00ff, 1, 100); // THREE prefix needed
        pointLight.position.set(50, 50, -50);
        scene.add(pointLight);

         const pointLight2 = new THREE.PointLight(0x00ffff, 1, 100); // THREE prefix needed
        pointLight2.position.set(-50, -50, 50);
        scene.add(pointLight2);


        // Create various geometries
        const geometries = [
            new THREE.BoxGeometry(1, 1, 1), // THREE prefix needed
            new THREE.SphereGeometry(0.75, 16, 16), // THREE prefix needed
            new THREE.ConeGeometry(0.75, 1.5, 16), // THREE prefix needed
            new THREE.CylinderGeometry(0.75, 0.75, 1.5, 16), // THREE prefix needed
            new THREE.TorusGeometry(0.5, 0.2, 10, 20), // THREE prefix needed
            new THREE.OctahedronGeometry(1), // THREE prefix needed
            new THREE.DodecahedronGeometry(1) // THREE prefix needed
        ];

        // Create the objects
        for (let i = 0; i < objectCount; i++) {
            // Random geometry
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];

            // Random vibrant color
            const material = new THREE.MeshPhongMaterial({ // THREE prefix needed
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6).getHex(), // THREE prefix needed for Color and setHSL method
                specular: 0x555555, // How shiny the surface is
                shininess: 30,     // How sharp the specular highlight is
            });

            const mesh = new THREE.Mesh(geometry, material); // THREE prefix needed

            // Random position within a sphere volume
            const radius = 80;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            mesh.position.x = radius * Math.sin(phi) * Math.cos(theta);
            mesh.position.y = radius * Math.sin(phi) * Math.sin(theta);
            mesh.position.z = radius * Math.cos(phi);

            // Random initial rotation
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;

            // Store unique animation properties for each object
            mesh.userData.speed = Math.random() * 0.01 + 0.005; // Slower/faster rotation
            // THREE prefix needed for Vector3 and normalize method
            mesh.userData.rotationAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(); // Random rotation axis centered around origin
            mesh.userData.originalColor = mesh.material.color.clone(); // clone doesn't need prefix, Color object does
            mesh.userData.originalScale = mesh.scale.clone(); // clone doesn't need prefix

            scene.add(mesh);
            objects.push(mesh); // Add to interactive objects list
        }

         // Set raycaster distance limit
         raycaster.far = camera.far;

        // Event listeners
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('click', onClick, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function onClick(event) {
        // Update the raycaster with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Check for intersections
        const intersects = raycaster.intersectObjects(objects); // intersectObjects is a Raycaster method

        if (intersects.length > 0) {
            // Get the first intersected object (closest one)
            const clickedObject = intersects[0].object;

            // Apply a click effect (e.g., scale pulse, color flash)
            clickedObject.userData.lastClickTime = performance.now();

            // Use TWEEN.js for smoother animation if imported successfully
            // Use TWEEN directly as imported
            if (typeof TWEEN !== 'undefined') { // Check TWEEN exists after import
                 // Animate scale up and back down
                new TWEEN.Tween(clickedObject.scale)
                    .to({ x: 1.5, y: 1.5, z: 1.5 }, 150) // Scale up in 150ms
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onComplete(() => {
                         new TWEEN.Tween(clickedObject.scale)
                             .to(clickedObject.userData.originalScale, 300) // Scale back to original
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                    })
                    .start();

                // Animate color flash
                // Need to create a new THREE.Color for the target
                 new TWEEN.Tween(clickedObject.material.color)
                    .to(new THREE.Color(0xffffff), 100) // Flash white (THREE prefix needed here)
                     .easing(TWEEN.Easing.Quadratic.Out)
                     .onComplete(() => {
                         // Wait briefly before restoring original color
                         setTimeout(() => {
                             // Ensure object wasn't just hovered and changed color again
                             if ((performance.now() - clickedObject.userData.lastClickTime) < 500) {
                                // Need to ensure the target is a THREE.Color if tweening to color object property
                                new TWEEN.Tween(clickedObject.material.color)
                                    .to(clickedObject.userData.originalColor, 400) // Fade back to original (using the stored clone)
                                    .easing(TWEEN.Easing.Quadratic.Out)
                                    .start();
                             }
                         }, 50);
                     })
                     .start();

            } else {
                // Fallback if TWEEN.js isn't loaded (less smooth)
                 clickedObject.scale.set(1.5, 1.5, 1.5);
                 setTimeout(() => clickedObject.scale.copy(clickedObject.userData.originalScale), 450);

                 clickedObject.material.color.setHex(0xffffff); // setHex is a THREE.Color method
                  setTimeout(() => clickedObject.material.color.copy(clickedObject.userData.originalColor), 500);
            }


        } else {
            // No object clicked
        }
    }


    function animate() {
        requestAnimationFrame(animate);

        // Update object positions/rotations for constant motion
        const time = performance.now() * 0.0001; // Use a slower time factor

        objects.forEach((obj, index) => {
            // Basic constant rotation around object's stored axis
            const rotationAmount = obj.userData.speed;
            // rotateOnAxis is a method of Object3D, called on the mesh instance
            obj.rotateOnAxis(obj.userData.rotationAxis, rotationAmount);

            // Add some subtle translation/wobble based on time
             obj.position.x += Math.sin(time * (index + 1) * 0.1) * 0.01;
             obj.position.y += Math.cos(time * (index + 1) * 0.15) * 0.01;
             obj.position.z += Math.sin(time * (index + 1) * 0.08) * 0.01;

            // Keep objects within bounds or wrap around (example: sphere boundary)
             const distFromCenter = obj.position.length();
             const boundaryRadius = 100;
             if (distFromCenter > boundaryRadius) {
                // Warp to opposite side and add some randomness
                 obj.position.multiplyScalar(-1);
                 // THREE prefix needed for Vector3 and MathUtils
                 obj.position.add(new THREE.Vector3(
                     THREE.MathUtils.randFloatSpread(5),
                     THREE.MathUtils.randFloatSpread(5),
                     THREE.MathUtils.randFloatSpread(5)
                 ));
             }
        });


        // Raycasting for hover effect
        raycaster.setFromCamera(mouse, camera);
        // intersectObjects is a method of Raycaster, called on the raycaster instance
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
            // There's at least one intersection
            const firstIntersected = intersects[0].object;

            if (intersectedObject != firstIntersected) {
                // A new object is being hovered

                // Restore previous hovered object's scale and color (if any)
                if (intersectedObject) {
                    // Check if the object was just clicked before restoring color/scale
                    if (!intersectedObject.userData.lastClickTime || (performance.now() - intersectedObject.userData.lastClickTime) > 400) {
                       intersectedObject.scale.copy(intersectedObject.userData.originalScale);
                       intersectedObject.material.color.copy(intersectedObject.userData.originalColor);
                    }
                    // If it was just clicked, let the click animation finish before allowing hover state change
                }

                 // Set the new hovered object IF it wasn't just clicked
                 if (!firstIntersected.userData.lastClickTime || (performance.now() - firstIntersected.userData.lastClickTime) > 400) {
                    intersectedObject = firstIntersected;

                     // Apply hover effect (e.g., glow color, slight scale)
                    intersectedObject.material.color.setHex(0xffff00); // setHex is a THREE.Color method
                    // Animate scale slightly up on hover using TWEEN if available
                    if (typeof TWEEN !== 'undefined') {
                         new TWEEN.Tween(intersectedObject.scale)
                             .to(intersectedObject.userData.originalScale.clone().multiplyScalar(1.1), 100)
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                     } else {
                         // Fallback if TWEEN not available
                          intersectedObject.scale.copy(intersectedObject.userData.originalScale.clone().multiplyScalar(1.1));
                     }
                 }


        }
        // If intersects.length > 0 and intersectedObject is the same, do nothing (already highlighted)

        } else {
            // No intersections
            if (intersectedObject) {
                // We were just hovering over an object, but now we're not
                // Restore its original scale and color if it wasn't just clicked
                if (!intersectedObject.userData.lastClickTime || (performance.now() - intersectedObject.userData.lastClickTime) > 400) {
                    if (typeof TWEEN !== 'undefined') {
                         new TWEEN.Tween(intersectedObject.scale)
                             .to(intersectedObject.userData.originalScale, 100)
                             .easing(TWEEN.Easing.Quadratic.Out)
                             .start();
                          // Need to ensure the target color is a THREE.Color if using tween.to(color_object)
                         new TWEEN.Tween(intersectedObject.material.color)
                            .to(intersectedObject.userData.originalColor, 100)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                     } else {
                          intersectedObject.scale.copy(intersectedObject.userData.originalScale);
                          intersectedObject.material.color.copy(intersectedObject.userData.originalColor);
                     }

                    intersectedObject = null; // Clear hovered object
                }
                 // If it *was* just clicked, we leave intersectedObject as is briefly
                 // to allow the click animation to potentially override the hover state change back.
                 // The check inside the if(intersects.length > 0) handles re-highlighting it if the mouse is still over it.
            }
        }


        // Update TWEEN.js animations if imported
        // Use TWEEN directly as imported
        if (typeof TWEEN !== 'undefined' && TWEEN.update) {
            TWEEN.update();
        }


        // Update controls (needed if controls.enableDamping is true)
        controls.update(); // Controls method

        // Render the scene
        renderer.render(scene, camera); // Renderer method

    }

</script>

</body>
</html>
